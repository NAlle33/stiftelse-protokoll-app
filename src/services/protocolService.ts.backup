/**
 * ProtocolService - Konsoliderad tjänst för protokollhantering
 * 
 * Denna tjänst konsoliderar funktionalitet från 5 tidigare protokolltjänster till en enhetlig implementation:
 * - Grundläggande protokolloperationer (CRUD)
 * - Versionshantering med kryptering och integritetskontroll
 * - Signeringsflöden med BankID-integration
 * - Arkivering och långtidslagring med GDPR-efterlevnad
 * - Mallar och innehållshantering
 * 
 * Följer BaseService-mönster för enhetlig felhantering, validering och caching.
 * Implementerar svensk lokalisering och GDPR-efterlevnad genomgående.
 */

import { BaseService, ValidationSchema } from './BaseService';
import { supabase } from './supabaseClient';

// Interfaces för protokolldata
export interface ProtocolTemplate {
  id: string;
  name: string;
  description: string;
  sections: ProtocolSection[];
  meeting_type: 'board' | 'annual' | 'constituting' | 'extraordinary';
  created_at: string;
  updated_at: string;
}

export interface ProtocolSection {
  id: string;
  title: string;
  content: string;
  order: number;
  required: boolean;
  editable: boolean;
}

export interface Protocol {
  id: string;
  meeting_id: string;
  title: string;
  status: 'draft' | 'review' | 'approved' | 'signed' | 'archived';
  sections: ProtocolSection[];
  template_id?: string;
  created_by: string;
  created_at: string;
  updated_at: string;
  gdpr_compliant: boolean;
  locked: boolean;
  // AI-metadata
  ai_generated?: boolean;
  ai_tokens_used?: number;
  ai_cost?: number;
}

export interface ProtocolVersion {
  id: string;
  protocol_id: string;
  version_number: number;
  content: string;
  content_hash: string;
  changes_summary: string;
  created_by: string;
  created_at: string;
  is_current: boolean;
  signature_status: 'unsigned' | 'pending' | 'signed';
  locked: boolean;
}

export interface SigningFlow {
  id: string;
  protocol_id: string;
  status: 'pending' | 'in_progress' | 'completed' | 'cancelled';
  required_signatures: SignatureRequirement[];
  completed_signatures: CompletedSignature[];
  created_at: string;
  completed_at?: string;
  immutable_hash: string;
}

export interface SignatureRequirement {
  user_id: string;
  role: 'chairman' | 'secretary' | 'member' | 'auditor';
  order: number;
  required: boolean;
}

export interface CompletedSignature {
  id: string;
  user_id: string;
  signed_at: string;
  bankid_reference: string;
  signature_hash: string;
}

export interface ArchiveEntry {
  id: string;
  protocol_id: string;
  archive_type: 'standard' | 'long_term' | 'legal_requirement';
  retention_period_years: number;
  destruction_date: string;
  blockchain_hash?: string;
  created_at: string;
  verified_at?: string;
}

export class ProtocolService extends BaseService {
  protected readonly serviceName = 'ProtocolService';
  
  // Validationsscheman
  protected readonly protocolSchema: ValidationSchema = {
    required: ['meeting_id', 'title', 'created_by'],
    types: {
      meeting_id: 'string',
      title: 'string',
      status: 'string',
      created_by: 'string',
      template_id: 'string'
    },
    patterns: {
      meeting_id: /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i,
      created_by: /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i
    },
    custom: {
      title: (value: string) => value.length >= 3 && value.length <= 200,
      status: (value: string) => ['draft', 'review', 'approved', 'signed', 'archived'].includes(value)
    }
  };

  protected readonly versionSchema: ValidationSchema = {
    required: ['protocol_id', 'content', 'created_by'],
    types: {
      protocol_id: 'string',
      content: 'string',
      changes_summary: 'string',
      created_by: 'string'
    },
    custom: {
      content: (value: string) => value.length > 0 && value.length <= 100000
    }
  };

  /**
   * === GRUNDLÄGGANDE PROTOKOLLOPERATIONER ===
   */

  /**
   * Hämtar alla tillgängliga protokollmallar
   */
  async getTemplates(): Promise<ProtocolTemplate[]> {
    return this.executeQuery(async () => {
      const { data, error } = await supabase
        .from('protocol_templates')
        .select('*')
        .order('name');

      if (error) throw error;
      return data || [];
    }, 'getTemplates');
  }

  /**
   * Hämtar en specifik protokollmall
   */
  async getTemplateById(templateId: string): Promise<ProtocolTemplate | null> {
    this.validateInput({ templateId }, {
      required: ['templateId'],
      types: { templateId: 'string' }
    });

    const cacheKey = `template_${templateId}`;
    const cached = this.getFromCache<ProtocolTemplate>(cacheKey);
    if (cached) return cached;

    const result = await this.executeQuery(async () => {
      const { data, error } = await supabase
        .from('protocol_templates')
        .select('*')
        .eq('id', templateId)
        .single();

      if (error) throw error;
      return data;
    }, 'getTemplateById');

    if (result) {
      this.setCache(cacheKey, result, 300); // Cache i 5 minuter
    }

    return result;
  }

  /**
   * Skapar ett nytt protokoll
   */
  async createProtocol(protocolData: Partial<Protocol>): Promise<Protocol> {
    this.validateInput(protocolData, this.protocolSchema);

    return this.executeQuery(async () => {
      const newProtocol = {
        ...protocolData,
        id: crypto.randomUUID(),
        status: 'draft',
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
        gdpr_compliant: true,
        locked: false
      };

      const { data, error } = await supabase
        .from('protocols')
        .insert(newProtocol)
        .select()
        .single();

      if (error) throw error;

      // Skapa första version
      await this.createVersion({
        protocol_id: data.id,
        content: JSON.stringify(data.sections || []),
        changes_summary: 'Första versionen av protokollet',
        created_by: data.created_by
      });

      return data;
    }, 'createProtocol');
  }

  /**
   * Hämtar ett protokoll med alla versioner
   */
  async getProtocol(protocolId: string): Promise<Protocol | null> {
    this.validateInput({ protocolId }, {
      required: ['protocolId'],
      types: { protocolId: 'string' }
    });

    const cacheKey = `protocol_${protocolId}`;
    const cached = this.getFromCache<Protocol>(cacheKey);
    if (cached) return cached;

    const result = await this.executeQuery(async () => {
      const { data, error } = await supabase
        .from('protocols')
        .select('*')
        .eq('id', protocolId)
        .single();

      if (error) throw error;
      return data;
    }, 'getProtocol');

    if (result) {
      this.setCache(cacheKey, result, 60); // Cache i 1 minut
    }

    return result;
  }

  /**
   * Hämtar alla protokoll för ett möte
   */
  async getProtocolsForMeeting(meetingId: string): Promise<Protocol[]> {
    this.validateInput({ meetingId }, {
      required: ['meetingId'],
      types: { meetingId: 'string' }
    });

    return this.executeQuery(async () => {
      const { data, error } = await supabase
        .from('protocols')
        .select('*')
        .eq('meeting_id', meetingId)
        .order('created_at', { ascending: false });

      if (error) throw error;
      return data || [];
    }, 'getProtocolsForMeeting');
  }

  /**
   * Uppdaterar ett protokoll
   */
  async updateProtocol(protocolId: string, updates: Partial<Protocol>): Promise<boolean> {
    this.validateInput({ protocolId, ...updates }, {
      required: ['protocolId'],
      types: { protocolId: 'string' }
    });

    // Kontrollera att protokollet inte är låst
    const protocol = await this.getProtocol(protocolId);
    if (!protocol) {
      throw this.createError('Protokoll hittades inte', 'NOT_FOUND');
    }

    if (protocol.locked) {
      throw this.createError('Protokollet är låst och kan inte redigeras', 'PROTOCOL_LOCKED');
    }

    return this.executeQuery(async () => {
      const { error } = await supabase
        .from('protocols')
        .update({
          ...updates,
          updated_at: new Date().toISOString()
        })
        .eq('id', protocolId);

      if (error) throw error;

      // Rensa cache
      this.clearCache(`protocol_${protocolId}`);
      
      return true;
    }, 'updateProtocol');
  }

  /**
   * Uppdaterar en specifik sektion i protokollet
   */
  async updateProtocolSection(
    protocolId: string, 
    sectionId: string, 
    content: string,
    userId: string
  ): Promise<boolean> {
    const protocol = await this.getProtocol(protocolId);
    if (!protocol) {
      throw this.createError('Protokoll hittades inte', 'NOT_FOUND');
    }

    if (protocol.locked) {
      throw this.createError('Protokollet är låst och kan inte redigeras', 'PROTOCOL_LOCKED');
    }

    const updatedSections = protocol.sections.map(section => 
      section.id === sectionId ? { ...section, content } : section
    );

    const success = await this.updateProtocol(protocolId, { sections: updatedSections });
    
    if (success) {
      // Skapa ny version för denna ändring
      await this.createVersion({
        protocol_id: protocolId,
        content: JSON.stringify(updatedSections),
        changes_summary: `Uppdaterade sektion: ${sectionId}`,
        created_by: userId
      });
    }

    return success;
  }

  /**
   * Genererar protokoll från transkribering med AI-integration
   */
  async generateProtocolFromTranscription(
    meetingId: string,
    transcription: string,
    userId: string,
    templateId?: string,
    aiOptions?: {
      model?: string;
      temperature?: number;
      maxTokens?: number;
    }
  ): Promise<Protocol> {
    this.validateInput({ meetingId, transcription, userId }, {
      required: ['meetingId', 'transcription', 'userId'],
      types: {
        meetingId: 'string',
        transcription: 'string',
        userId: 'string'
      },
      custom: {
        transcription: (value: string) => value.length > 50 && value.length <= 100000
      }
    });

    return this.executeQuery(async () => {
      // Hämta mötesdata för kontext
      const { data: meeting, error: meetingError } = await supabase
        .from('meetings')
        .select('title, meeting_type, organization_name, meeting_date, participants')
        .eq('id', meetingId)
        .single();

      if (meetingError) {
        throw this.createError('Kunde inte hämta mötesdata', 'NOT_FOUND');
      }

      // Hämta mall om specificerad
      const template = templateId ? await this.getTemplateById(templateId) : null;

      // Importera ProtocolAIService dynamiskt för att undvika cirkulära beroenden
      const { protocolAIService } = await import('./protocolAIService');

      // Skapa AI-genereringsförfrågan
      const aiRequest = {
        transcription,
        meetingId,
        meetingType: meeting.meeting_type || 'board_meeting',
        organizationName: meeting.organization_name || 'Okänd organisation',
        meetingDate: meeting.meeting_date || new Date().toISOString().split('T')[0],
        participants: meeting.participants || [],
        templateId,
        userId,
        aiOptions
      };

      // Generera protokoll med AI
      const aiResponse = await protocolAIService.generateProtocol(aiRequest);

      if (!aiResponse.success) {
        throw this.createError(
          `AI-protokollgenerering misslyckades: ${aiResponse.error}`,
          'AI_GENERATION_ERROR'
        );
      }

      // Konvertera AI-genererat protokoll till strukturerade sektioner
      const sections = this.parseAIProtocolToSections(aiResponse.protocol, template);

      // Skapa protokoll i databasen
      const protocol = await this.createProtocol({
        meeting_id: meetingId,
        title: `Protokoll - ${meeting.title || new Date().toLocaleDateString('sv-SE')}`,
        sections,
        template_id: templateId,
        created_by: userId
      });

      // Uppdatera protokoll med AI-metadata
      await this.updateProtocol(protocol.id, {
        ai_generated: true,
        ai_tokens_used: aiResponse.tokensUsed,
        ai_cost: aiResponse.cost,
        gdpr_compliant: aiResponse.gdprCompliant
      });

      return protocol;
    }, 'generateProtocolFromTranscription');
  }

  /**
   * Parsar AI-genererat protokoll till strukturerade sektioner
   */
  private parseAIProtocolToSections(aiProtocol: string, template?: ProtocolTemplate): ProtocolSection[] {
    // Standardsektioner om ingen mall finns
    const defaultSections = [
      { id: 'agenda', title: 'Dagordning', order: 1, required: true, editable: true },
      { id: 'decisions', title: 'Beslut', order: 2, required: true, editable: true },
      { id: 'actions', title: 'Åtgärder', order: 3, required: false, editable: true },
      { id: 'notes', title: 'Anteckningar', order: 4, required: false, editable: true }
    ];

    const baseSections = template?.sections || defaultSections;

    // Enkel parsing - dela upp protokollet baserat på rubriker
    const sections: ProtocolSection[] = baseSections.map(baseSection => {
      // Försök hitta innehåll för denna sektion i AI-protokollet
      const sectionRegex = new RegExp(`${baseSection.title}[:\\s]*([\\s\\S]*?)(?=\\n\\n[A-ZÅÄÖ]|$)`, 'i');
      const match = aiProtocol.match(sectionRegex);

      return {
        ...baseSection,
        content: match ? match[1].trim() : ''
      };
    });

    // Om inget innehåll hittades i sektioner, lägg allt i första sektionen
    const hasContent = sections.some(section => section.content.length > 0);
    if (!hasContent && sections.length > 0) {
      sections[0].content = aiProtocol;
    }

    return sections;
  }

  /**
   * Hämtar status för AI-protokollgenerering
   */
  async getAIGenerationStatus(meetingId: string): Promise<any> {
    this.validateInput({ meetingId }, {
      required: ['meetingId'],
      types: { meetingId: 'string' }
    });

    // Importera ProtocolAIService dynamiskt
    const { protocolAIService } = await import('./protocolAIService');
    return protocolAIService.getGenerationStatus(meetingId);
  }

  /**
   * Prenumerera på AI-genereringsstatusupdateringar
   */
  async subscribeToAIGenerationStatus(
    meetingId: string,
    callback: (status: any) => void
  ): Promise<() => void> {
    this.validateInput({ meetingId }, {
      required: ['meetingId'],
      types: { meetingId: 'string' }
    });

    // Importera ProtocolAIService dynamiskt
    const { protocolAIService } = await import('./protocolAIService');
    return protocolAIService.subscribeToStatus(meetingId, callback);
  }

  /**
   * Uppskattar kostnad för AI-protokollgenerering
   */
  async estimateAIGenerationCost(transcriptionLength: number): Promise<{ estimatedCost: number; currency: string }> {
    // Importera ProtocolAIService dynamiskt
    const { protocolAIService } = await import('./protocolAIService');
    return protocolAIService.estimateCost(transcriptionLength);
  }
}
